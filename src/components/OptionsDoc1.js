export default {

	chart: {
		axesTitlesSize: { meta: {  type: "number / delegate", help: "axes titles font sizes", name: "axesTitleSize", name: "axesTitlesSize", model: '' }},
		background: { meta: {  type: "string / delegate", help: "background of the chart area", name: "background", name: "background", model: ''}},
		categoriesAxis: { meta: {  type: "object", help: "defines which elements (line and labels) of the category chart axis should be rendered", name: "categoriesAxis", model: '' }},
		categoriesKey: { meta: {  type: "string / delegate", help: "key of categories in series data objects", name: "categoriesKey", model: '' }},
		categoriesLabels: { meta: {  type: "delegate", help: "a function which is being applied one by one for every categories axis label. It takes the current **label** and the **value** of the first chart's entry connected to the category as parameters, and expects the updated label as a return value.", name: "categoriesLabels", model: '' }},
		categoriesTitle: { meta: {  type: "string / delegate", help: "title for the categories axis", name: "categoriesTitle", model: '' }},
		categoryAxisLabelsSize: { meta: {  type: "number / delegate", help: "category axis labels' font size", name: "categoryAxisLabelsSize", model: '' }},
		centerOrigin: { meta: {  type: "boolean / delegate", help: "defines whether the origin (zero line) should be at the center of the chart.", name: "centerOrigin", model: '' }},
		clusterScalingSize: { meta: {  type: "number", help: "defines the total width of a whole cluster in percents of a bandwidth (the whole category width)", name: "clusterScalingSize", model: '' }},
		clustered: { meta: {  type: "boolean / delegate", help: "defines whether the data representations should start at the end of the previous ones in categories axis", name: "clustered", model: '' }},
		dataColorsScheme: { meta: {  type: "string / array", help: "name of the one of default color schemes for the chart that is included in the library, or custom color scheme passed as an array of color values. At the chart level the next color from the provided colors array or the default scheme is assigned for every series", name: "dataColorsScheme", model: '' }},
		dataLabelsDecimals: { meta: {  type: "number", help: "the number of decimals to be rendered in data labels of all series. It has a lower priority than similar setting for specific series.", name: "dataLabelsDecimals", model: '' }},
		dataLabelsMargin: { meta: {  type: "number / delegate", help: "data labels' margin from data representation", name: "dataLabelsMargin", model: '' }},
		dataLabelsSeparators: { meta: {  type: "object", help: "defines which separators should be used for data labels. It overwrites the default ones and small multiple's, but has got a lower priority than similar settings for series.", name: "dataLabelsSeparators", model: '' }},
		dataLabelsSize: { meta: {  type: "number / delegate", help: "data labels' font size", name: "dataLabelsSize", model: '' }},
		dataOuterPadding: { meta: {  type: "number / delegate", help: "padding of the first and last data representations in percents", name: "dataOuterPadding", model: '' }},
		decimals: { meta: {  type: "number", help: "the number of decimals to be rendered in data labels of a particular axis. It is ignored by default.", name: "decimals", model: '' }},
		eventSubscribers: { meta: {  type: "array", help: "custom events subscribers, see more in [Events](/events)", name: "eventSubscribers", model: '' }},
		eventsTypes: { meta: {  type: "string", help: "events types used by interaction manager, see more in [Events](/events). Currently supported `eventTypes` implemented by the library:", name: "eventsTypes", model: '' }},
		fixedInterval: { meta: {  type: "boolean / number", help: "defines a fixed interval between ticks.", name: "fixedInterval", model: '' }},
		forecastOpacity: { meta: {  type: "number / delegate", help: "opacity of forecasted data representation in percents", name: "forecastOpacity", model: '' }},
		forecastStart: { meta: {  type: "string / number / delegate", help: "column value at which the forecast starts", name: "forecastStart", model: '' }},
		gridlines: { meta: {  type: "boolean / delegate", help: "defines whether the grid lines for values should be rendered", name: "gridlines", model: '' }},
		labelColor: { meta: {  type: "stirng", help: "color of legend labels.", name: "labelColor", model: '' }},
		labelHighlightColor: { meta: {  type: "stirng", help: "color of highlighted legend label.", name: "labelHighlightColor", model: '' }},
		labels: { meta: {  type: "boolean", help: "defines whether the labels should be rendered", name: "labels", model: '' }},
		labelsMargin: { meta: {  type: "number", help: "margin of legend labels from shapes in px.", name: "labelsMargin", model: '' }},
		labelsSize: { meta: {  type: "number", help: "size of legend labels in px.", name: "labelsSize", model: '' }},
		legend: { meta: {  type: "object / delegate", help: "configuration for chart legend.", name: "legend", model: '' }},
		line: { meta: {  type: "boolean", help: "defines whether the line should be rendered", name: "line", model: '' }},
		margin: { meta: {  type: "object", help: "legend margins, it is an object containing fields `top`, `right`, `bottom` and `left`.", name: "legend.margin", model: '' }},
		marksVisible: { meta: {  type: "boolean", help: "defines whether the ticks marks should be rendered", name: "marksVisible", model: '' }},
		matchStackTo100: { meta: {  type: "boolean", help: "defines whether the stacked series should be extended to fill the full size of a container. Data labels are rendered at the center of data representations in this case, and show percentage of the value in a stack instead of the actual value.", name: "matchStackTo100", model: '' }},
		mergeSeriesCategories: { meta: {  type: "boolean / delegate", help: "defines whether the categories from every series should be shown on the graph.", name: "mergeSeriesCategories", model: '' }},
		noDataMessage: { meta: {  type: "string / delegate", help: "message displayed when there is no data in series", name: "noDataMessage", model: '' }},
		orientation: { meta: {  type: "string / delegate", help: "chart orientation, either vertical or horizontal", name: "orientation", model: '' }},
		overlapping: { meta: {  type: "number", help: "defines whether and by how much the data representations should overlap the previous ones in categories axis", name: "overlapping", model: '' }},
		overlappingType: { meta: {  type: "string", help: "defines the type of overlapping. Itâ€™s applied when `overlapping` is set.", name: "overlappingType", model: '' }},
		position: { meta: {  type: "string", help: "it can be set either to `top` or `bottom` and it sets the position of legend on the chart.", name: "position", model: '' }},
		primaryValuesAxis: { meta: {  type: "object", help: "defines ticks adjustments options and which elements (line and labels) of the primary (left or bottom) chart axis should be rendered", name: "primaryValuesAxis", model: '' }},
		primaryValuesTitle: { meta: {  type: "string / delegate", help: "title of the the primary values axis", name: "primaryValuesTitle", model: '' }},
		secondaryValuesAxis: { meta: {  type: "object", help: "defines ticks adjustments options and which elements (line and labels) of the secondary (right or top) chart axis should be rendered.", name: "secondaryValuesAxis", model: '' }},
		secondaryValuesTitle: { meta: {  type: "string / delegate", help: "title of the secondary values axis", name: "secondaryValuesTitle", model: '' }},
		separators: { meta: {  type: "object", help: "it works the same as **separators** option for [Series](/series), but is applied for particular values axis' labels.", name: "separators", model: '' }},
		series: { meta: {  type: "array", help: "array of series or groups of series to be rendered on a chart", name: "series", model: '' }},
		shapesSize: { meta: {  type: "number", help: "width and height of a graphical shape in legend entry.", name: "shapesSize", model: '' }},
		showVersion: { meta: {  type: "boolean / delegate", help: "defines whether the library version should be rendered at the bottom right of the chart", name: "showVersion", model: '' }},
		stacked: { meta: {  type: "boolean / delegate", help: "defines whether the data representations should start at the end of the previous ones in values axis", name: "stacked", model: '' }},
		thumbnail: { meta: {  type: "boolean", help: "defines whether the chart should be drawn as a thumbnail. It is a shortcut for setting the following chart options:", name: "thumbnail", model: '' }},
		ticks: { meta: {  type: "object", help: "ticks configuration object", name: "ticks", model: '' }},
		truncateTitles: { meta: {  type: "boolean / delegate", help: "defines whether the horizontal axes titles should be truncated (or hidden) if there is not enough space to render them.", name: "truncateTitles", model: '' }},
		valueKeys: { meta: {  type: "array / delegate", help: "array of keys of fields in series data that should be treated as values", name: "valueKeys", model: '' }},
		valuesAxesDecimals: { meta: {  type: "number", help: "the number of decimals to be rendered in data labels of both values axes. It has a lower priority than a similar setting for particular labels and is ignored by default.", name: "valuesAxesDecimals", model: '' }},
		valuesAxesLabelsSize: { meta: {  type: "number / delegate", help: "values axes labels' font size", name: "valuesAxesLabelsSize", model: '' }},
		valuesAxesSeparators: { meta: {  type: "object", help: "defines which separators should be used for values axes labels. It overwrites the default ones, but has got a lower priority than similar settings for axes.", name: "valuesAxesSeparators", model: '' }},
		visible: { meta: {  type: "boolean", help: "defines whether the legend should be rendered.", name: "legend.visible", model: '' }},
		xLabelsResponsiveness: { meta: { type: "array", help: "defines how the responsiveness of x axes labels should behave.", name: "xLabelsResponsiveness", model: '' }}
	},

	events: {
		chartData: { meta: {  type: "object", help: "chart data object that is used internally by the chart library", name: "chartData", model: '' }},
		element: { meta: {  type: "string", help: "type of registered roi chart element", name: "element", model: '' }},
		event: { meta: {  type: "object", help: "information about emitted event, it consists of:", name: "event", model: '' }},
		eventData: { meta: {  type: "object", help: "dynamic event data, it depends on event type", name: "eventData", model: '' }},
		html: { meta: {  type: "function", help: "rendering function provided by [hyperHTML](https://viperhtml.js.org/hyper.html). `html` will render given template at the event position. ", name: "html", model: '' }},
		interactionsEventManager: { meta: {  type: "object", help: "service that handles chart interactions, used version of interaction manager depends on the `eventsTypes` set in the chart config, see more in [Chart](/chart)", name: "interactionsEventManager", model: '' }},
		pubSub: { meta: {  type: "object", help: "service that allows publishing and subscribing to the roi chart events", name: "pubSub", model: '' }},
		services: { meta: {  type: "object", help: "object with public services that are used inside chart library, it consists of:", name: "services", model: '' }},
		source: { meta: {  type: "object", help: "DOM event that caused roi chart event", name: "source", model: '' }},
		tooltipManager: { meta: {  type: "object", help: "service that handles state of the tooltips", name: "tooltipManager", model: '' }},
		type: { meta: { type: "string", help: "type of registered roi chart event", name: "type", model: '' }}
	},

	forecastColumns: {
		forecastOpacity: { meta: {  type: "number", help: "opacity of forecasted bars in percents", name: "forecastOpacity", model: '' }},
		forecastStart: { meta: { type: "string / number", help: "column value at which the forecast starts", name: "forecastStart", model: '' }}
	},

	groups: {
		name: { meta: {  type: "string", help: "name of a group", name: "name", model: '' }},
		series: { meta: { type: "array", help: "array of series to be rendered on a chart", name: "series", model: '' }}
	},

	sankeyDiagram: {
		data: { meta: {  type: "object", help: "object containing information about nodes and links between them.", name: "data", model: '' }},
		links: { meta: {  type: "array", help: "an array containing links objects which are described below.", name: "links", model: '' }},
		name: { meta: {  type: "string", help: "name of the node, it is used as a label", name: "name", model: '' }},
		noDataMessage: { meta: {  type: "string / delegate", help: "message displayed when there is no data in links or nodes", name: "noDataMessage", model: '' }},
		node: { meta: {  type: "number", help: "id of the node, it is used to identify the node while making links", name: "node", model: '' }},
		nodePadding: { meta: {  type: "number", help: "spacing between neighboring nodes in px", name: "nodePadding", model: '' }},
		nodeWidth: { meta: {  type: "number", help: "width of nodes in px", name: "nodeWidth", model: '' }},
		nodes: { meta: {  type: "array", help: "an array containing nodes objects which are described below.", name: "nodes", model: '' }},
		pathOpacity: { meta: {  type: "number", help: "opacity of paths between nodes in percents", name: "pathOpacity", model: '' }},
		source: { meta: {  type: "number", help: "id of the starting node of a link", name: "source", model: '' }},
		target: { meta: {  type: "number", help: "id of the target node of a link", name: "target", model: '' }},
		value: { meta: { type: "number", help: "size of a link - sum of all values of links starting from a node is 100% of node's height", name: "value", model: '' }}
	},

	series: {
		align: { meta: {  type: "string", help: "defines where the number labels should be aligned. Possible values: `left`, `center`, `right`. It works only for horizontal charts.", name: "align", model: '' }},
		assignTo: { meta: {  type: "string", help: "assigns a series to a particular values axis, possible values: `primary`, `secondary`", name: "assignTo", model: '' }},
		bodyType: { meta: {  type: "string", help: "shape of the main piece of two-piece data representations, possible values: `square`, `circle`", name: "bodyType", model: '' }},
		candlestickLineColor: { meta: {  type: "string / array / object", help: "color for candlestick line, see `dataColor` ", name: "candlestickLineColor", model: '' }},
		categoriesSetter: { meta: {  type: "boolean", help: "defines whether only the categories from the current series should be shown on the graph", name: "categoriesSetter", model: '' }},
		color: { meta: {  type: "string", help: "the color of data labels.", name: "color", model: '' }},
		colorFromData: { meta: {  type: "boolean", help: "defines whether the labels color should be inherited from the data representation. It overwrites the **color** setting.", name: "colorFromData", model: '' }},
		colors: { meta: {  type: "string / array", help: "color for values, see `string` and `array` variations of `dataColor`", name: "colors", model: '' }},
		cut: { meta: {  type: "number / array", help: "cuts data representations above a given value and adds a triangle indicator to labels of cut data. Cut data is not taken into account in domain calculations. It can be passed as a:", name: "cut", model: '' }},
		dashed: { meta: {  type: "boolean", help: "defines whether the line connecting data points should be dashed", name: "dashed", model: '' }},
		data: { meta: {  type: "array", help: "array with series data, in form of:", name: "data", model: '' }},
		dataColor: { meta: {  type: "string / array / object", help: "color of series data representation. It overrides `dataColorsScheme` used at chart level and series level. It could be passed as a:", name: "dataColor", model: '' }},
		dataColorsScheme: { meta: {  type: "string / array / delegate", help: "name of the one of default color schemes for series that is included in the library, or custom color scheme passed as an array of color values. At the series level, the next color from the provided colors array or the default scheme is assigned to every data in the series. It overrides `dataColorsScheme` used at chart level.", name: "dataColorsScheme", model: '' }},
		dataLabels: { meta: {  type: "object", help: "configuration for data labels.", name: "dataLabels", model: '' }},
		dataLabelsThreshold: { meta: {  type: "number / array", help: "show threshold label instead of a full label when value is above a given value. It can be passed as a:", name: "dataLabelsThreshold", model: '' }},
		decimal: { meta: {  type: "string", help: "decimal separator for labels, example for \"x\" string: `12345678.9` -> `12345678x9`", name: "decimal", model: '' }},
		decimals: { meta: {  type: "number", help: "the number of decimals to be rendered in a data label.", name: "decimals", model: '' }},
		fixedColors: { meta: {  type: "array", help: "array of objects representing categories that should have fixed colors regardless of used `dataColor` or `dataColorsScheme` settings, every object could have following fields:", name: "fixedColors", model: '' }},
		labelBold: { meta: {  type: "boolean", help: "defines whether the label of data representation should be bold.", name: "labelBold", model: '' }},
		labelSize: { meta: {  type: "number", help: "the size of a label of data representation, it overwrites the global labels size", name: "labelSize", model: '' }},
		lineSize: { meta: {  type: "number", help: "width of the line in \"two-piece\" data representations", name: "lineSize", model: '' }},
		lines: { meta: {  type: "boolean", help: "defines whether the lines connecting bars should be rendered", name: "lines", model: '' }},
		name: { meta: {  type: "string", help: "name of series", name: "name", model: '' }},
		neutralInterval: { meta: {  type: "number / array", help: "interval for neutral values, used for assigning colors of data representation in `dataColor` and `fixedColors` options. It could be passed as a:", name: "neutralInterval", model: '' }},
		noBreaks: { meta: {  type: "boolean", help: "defines whether the line connecting data points should break when there is no value for a given category", name: "noBreaks", model: '' }},
		order: { meta: {  type: "number", help: "defines in what order the data series should be rendered - series with lower value will be drawn on top of the ones with a higher value", name: "order", model: '' }},
		overallResultVisualization: { meta: {  type: "object", help: "configuration for special overall result visualization.", name: "overallResultVisualization", model: '' }},
		particularLabels: { meta: {  type: "array", help: "array of objects containing configuration for separate labels.", name: "particularLabels", model: '' }},
		refCategory: { meta: {  type: "string", help: "name of the category of label to which the options should be applied", name: "refCategory", model: '' }},
		refValues: { meta: {  type: "string", help: "name of the key in series that should be as a base to apply negative/positive/neutral color", name: "refValues", model: '' }},
		remaining: { meta: {  type: "number", help: "the remaining value in visualization, it is rendered as the last category.", name: "remaining", model: '' }},
		remainingLabel: { meta: {  type: "string", help: "the label of remaining visualization category.", name: "remainingLabel", model: '' }},
		remainingSpecial: { meta: {  type: "boolean", help: "defines whether the remaining visualization is rendered as an arrow. If false, then it is rendered as a normal data representation and is taken into account in domains calculations.", name: "remainingSpecial", model: '' }},
		separators: { meta: {  type: "object", help: "defines which separators should be used for data labels. It overwrites the default, small multiple's, and series' ones.", name: "separators", model: '' }},
		showPlusSign: { meta: {  type: "boolean", help: "defines whether the labels for the positive values should have a plus sign rendered before the values.", name: "showPlusSign", model: '' }},
		size: { meta: {  type: "number", help: "data representation size, if in percents then it refers to the allowed bandwidth", name: "size", model: '' }},
		thousands: { meta: {  type: "string", help: "thousands separator for labels, example for \"x\" string: `12345678.9` -> `12x345x678.9`", name: "thousands", model: '' }},
		total: { meta: {  type: "number", help: "the total value in visualization, it is rendered as the first category.", name: "total", model: '' }},
		totalLabel: { meta: {  type: "string", help: "the label of total visualization category.", name: "totalLabel", model: '' }},
		totalSpecial: { meta: {  type: "boolean", help: "defines whether the total visualization is rendered as an arrow. If false, then it is rendered as a normal data representation and is taken into account in domains calculations.", name: "totalSpecial", model: '' }},
		type: { meta: {  type: "string", help: "type of data representation, possible values: `bar`, `bullet`, `inset`, `candlestick`, `dot`, `line`, `target`, `waterfall`, `number`", name: "type", model: '' }},
		undecorated: { meta: {  type: "boolean", help: "defines whether the line should not have dots in data points", name: "undecorated", model: '' }},
		valueKey: { meta: {  type: "string", help: "key of fields series data that should be treated as values", name: "valueKey", model: '' }},
		visible: { meta: { type: "boolean", help: "defined whether the data labels for the data representations should be rendered.", name: "visible", model: '' }}
	},

	smallMultiples: {
		background: { meta: {  type: "string / delegate", help: "background of the small multiples area. It has a lower priority than chessboardBackground option and backgrounds of separate subcharts.", name: "background", model: '' }},
		categoriesAxis: { meta: {  type: "object", help: "works as described in [Chars](charts).", name: "categoriesAxis", model: '' }},
		centerOrigins: { meta: {  type: "boolean", help: "defines whether the origins (zero lines) of charts in a small multiple should be centered.", name: "centerOrigins", model: '' }},
		charts: { meta: {  type: "2D array", help: "two-dimensional (rows and columns) array of charts to be rendered in small multiples.", name: "charts", model: '' }},
		chessboardBackground: { meta: {  type: "array", help: "an array containing colors of subcharts - the first color is used for charts with odd indices, and the last one for charts with even indices. It has a lower priority than backgrounds of separate subcharts.", name: "chessboardBackground", model: '' }},
		dataLabelsDecimals: { meta: {  type: "number", help: "the number of decimals to be rendered in data labels of all charts' series. It has a lower priority than similar settings for specific charts and series.", name: "dataLabelsDecimals", model: '' }},
		dataLabelsSeparators: { meta: {  type: "object", help: "defines which separators should be used for data labels. It has got a lower priority than similar settings for a chart or series.", name: "dataLabelsSeparators", model: '' }},
		gridSizing: { meta: {  type: "object", help: "object containing information about the sizing of charts in small multiples.", name: "gridSizing", model: '' }},
		margin: { meta: {  type: "object", help: "works as described in [Chart](/chart), but for all charts in small multiples.", name: "margin", model: '' }},
		noDataMessage: { meta: {  type: "string / delegate", help: "message displayed on any of the sub charts when there is no data in it's series", name: "noDataMessage", model: '' }},
		separators: { meta: {  type: "object", help: "defines which separators should be used for both data labels and axes labels. It has got a lower priority than similar settings for a chart or series.", name: "separators", model: '' }},
		truncateTitles: { meta: {  type: "boolean", help: "works as described in [Chart](/chart), but for all charts in small multiples. It has a lower priority than the same option for particular sub-charts.", name: "truncateTitles", model: '' }},
		valuesAxesDecimals: { meta: { type: "number", help: "the number of decimals to be rendered in data labels of both values axes in every chart. It has a lower priority than a similar setting for the particular chart or particular labels and is ignored by default.", name: "valuesAxesDecimals", model: '' }}
	},

	sunburstDiagram: {
		children: { meta: {  type: "array", help: "an array containing child nodes, it should be provided if there is no `size` in current node", name: "children", model: '' }},
		data: { meta: {  type: "object", help: "object with tree structure that contains nodes", name: "data", model: '' }},
		name: { meta: {  type: "string", help: "name of the node", name: "name", model: '' }},
		noDataMessage: { meta: {  type: "string / delegate", help: "message displayed when there is no data in root node", name: "noDataMessage", model: '' }},
		size: { meta: {  type: "number", help: "size of node - the sum of the size of all children's nodes is 100% of current node's size. It should be provided if current node doesn't have `children`", name: "size", model: '' }},
		sunburstLabels: { meta: {  type: "boolean", help: "defines whether the labels on the sunburst diagram should be rendered", name: "sunburstLabels", model: '' }},
		sunburstLabelsSize: { meta: {  type: "number / delegate", help: "sunburst labels' font size", name: "sunburstLabelsSize", model: '' }},
		sunburstZoomTransition: { meta: { type: "number / delegate", help: "transition time in [ms] of zooming in/out afer clicking on the node", name: "sunburstZoomTransition", model: '' }}
	},

	xAxesLabelsResponsiveness: {
		consistent: { meta: {  type: "boolean", help: "defines whether the option should apply to all labels in an axis", name: "consistent", model: '' }},
		extendTicks: { meta: {  type: "object / delegate", help: "defines whether the ticks with even indices should be longer than the others", name: "extendTicks", model: '' }},
		hideLabels: { meta: {  type: "object / delegate", help: "defines whether the overflowing labels should be hidden", name: "hideLabels", model: '' }},
		minWidth: { meta: {  type: "number / delegate", help: "defines the minimal width of the chart that is required to apply responsiveness settings from the current object", name: "minWidth", model: '' }},
		primaryAxisLabels: { meta: {  type: "array", help: "axis labels of the primary axis", name: "primaryAxisLabels", model: '' }},
		secondaryAxisLabels: { meta: {  type: "array", help: "axis labels of the secondary axis", name: "secondaryAxisLabels", model: '' }},
		truncateLabels: { meta: {  type: "object / delegate", help: "the length to which the overflowing labels are truncated", name: "truncateLabels", model: '' }},
		value: { meta: { type: "boolean", help: "triggers the option", name: "value", model: '' }}
	}
}
